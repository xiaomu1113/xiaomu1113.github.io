[{"content":"图片显示不出来 (该部分为转载) 原文地址\n以微博作为图床，将图片通过微博发布后再拷贝其图像链接至文档即可\n具体操作：\nstep1：下载微博图床插件 下载地址\nstep2: 在浏览器中打开管理拓展，打开开发者模式，再点击加载解压缩的扩展，导入解压后的图床插件\nstep3：上微博号，打开插件即可上传图片\n如果你想删掉某一张图，点击\u0026quot;设置/历史\u0026quot;即可\n","date":"2023-09-05T19:48:39+08:00","permalink":"https://xiaotianmuyun1113.top/p/blog%E7%BC%96%E5%86%99%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Blog编写中遇到的问题"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\nturtle库概述 turtle(海龟)库是turtle绘图体系的Python实现，是Python语言的标准库之一\nturtle库通过窗体中海龟的移动，隐藏或显示海龟的移动轨迹来进行图形的绘制，可以通过代码来改变轨迹的粗细，颜色等特性\nturtle库的绘图窗体 指令：turtle.setup(width, height, startx, starty)\n后两个参数不是必须的，若没有则窗口中心点默认置于屏幕中心点处\nturtle库的空间坐标体系 绝对坐标 即以屏幕的中心点作为坐标系的原点，然后以一个像素作为一个单位长度，以水平向右为x轴正方向，竖直向上为y轴正方向，对窗口中的每个点进行唯一确定的坐标表示\nturtle.goto(x, y)即让海龟沿直线从当前位置移动到点(X, Y)处\n海龟坐标 即以海龟头部为正方向，来进行控制\nturtle.fd(d)即让海龟前进d个像素\nturtle.bk(d)即让海龟后退d个像素\nturtle.circle(r, angle)即让海龟沿着半径为r（r为正时圆在海龟的左手边）的圆移动到距当前点angle（angle为正时即为逆时针运动）角度的点上\nturtle的角度坐标体系 绝对角度 以水平向右为0°，竖直向上为90°，对海龟头部的角度进行描述\nturtle.seth(angle)即让海龟的头部转到angle的方向上，其中angle为绝对角度，seth函数使用后海龟只转向而不行进\n海龟角度 以海龟头现方向为正方向，来描述转向\nturtle.left/right(angle)即让海龟向左/右转向angle的角度\nRGB色彩体系 RGB指的是红绿蓝三个通道的颜色组合，通过控制每个通道的参数来改变所得到的颜色，\n","date":"2023-09-02T20:20:08+08:00","permalink":"https://xiaotianmuyun1113.top/p/turtle%E5%BA%93/","title":"Turtle库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\n编译和解释 编译 将源代码一次性转换成目标代码的过程\n解释 将源代码逐条转换成目标代码同时逐条执行的过程(类似同声传译)\n程序的编写方法and思想 IPO I：Input 程序的输入(文件，网络，控制台，交互界面，内部参数)\nP: Proce 对于输入数据的处理，即算法，是一个程序的灵魂所在\nO: Output 结果的输出(控制台，图形，网络，文件，内部参数)\nIPO思想是编写程序的基本思想，根据用户的输入和所需的输出，进行主体程序的设计和编写，是最简单粗暴的思路。\npython开发环境 python基本开发环境IDLE python官方提供，适用于小规模程序开发\n优点：轻量级，使用灵活；功能丰富，拥有众多标准库以及第三方库可供使用。\n下载地址\npython高级开发环境VSCode 配置该环境时要先布局IDLE，后下载VSCode下载地址\npython的计算生态 标准库+第三方库\n标准库：随解释器直接安装到操作系统中的功能模块\n第三方库：需要经过安装才能使用的功能模块\n两种编程方式 交互式：对每个输入语句立即运行结果\n文件式：代码在py文件中编写完成后一次性进行运行，是编程的主要方式\n程序的格式框架 缩进：一行代码开始前的空白部分，用于指出程序的层次结构；是语法的一部分，缩进错误程序也会报错；一个程序中的缩进一般一致，统一为1个Tab或4个空格\n注释：不被程序执行的辅助性文字，用于提高代码的可读性；若单行则以#开头，若多行则以\u0026rsquo;\u0026lsquo;\u0026lsquo;开头和结尾\n命名与保留字 变量：程序中用于保存和表示数据的占位符号\n命名：用=将变量和标识符关联起来的过程，命名要遵循许多规则，如：可为大小写字母，数字，下划线和中文字符或其组合；大小写敏感；首字符不能为数字；不与保留字相同\n保留字：被编程语言内部定义并保留使用的标识符。python中有35个保留字，它们分别为以下图片中所示\n","date":"2023-09-02T13:12:23+08:00","permalink":"https://xiaotianmuyun1113.top/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Python基础语法"},{"content":"数据排序 数据获取后，要对所得的数据进行简单加工处理，使原本杂乱的数据变得有序，便于后续的利用。\n选择排序 基本思想：从未排序的数据中挑出一个最大的（或最小的）数据，后将其放到数列的最前端，重复该操作，最终得到排好序的数列。\n稳定性：不稳定（即非相邻两个数据间的交换会改变相同数据的先后关系）\n时间复杂度：O(n2)（即一组个数为n的数据，排序的主体操作进行的次数要达n的平方次）\n空间复杂度：O(1)（即除了储存数据所用的空间外，无需其他辅助空间）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void selection(int a[]) { int temp = 0; for (int i=1; i\u0026lt;n; i++) //最小值存放的位置 { int k = i; //当前最小值 for (int j=i+1; j\u0026lt;=n; j++) if (a[j] \u0026lt; a[k]) k = j; if (k != i) //交换过程 { temp = a[i]; a[i] = a[k]; a[k] = temp; } } } 冒泡排序 基本思想：从数组中的第一个数开始，将其与后一个数进行比较，若后一个数比前一个数小（或大），就将两个数进行交换。经过n次遍历后，即可得到数据从小到大（或从大到小）排列的数组。\n排序的优化：若其中一次遍历结束后，数组中的数没有发生交换，说明排序提前完成，此时可中断排序，节省时间。\n稳定性：稳定\n时间复杂度：O(n2)\n空间复杂度：O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void bubble(int a[]) { bool ok; for (int i=n; i\u0026gt;1; i--) { ok = false; //判断是否发生过交换 for (int j=1; j\u0026lt;i; j++) { if (a[j] \u0026gt; a[j+1]) { swap(a[j],a[j+1]); ok = true; } } if (ok == false) break; //若该次循环内没有发生交换，则排序完成，无需继续循环。 } } 快速排序 基本思想：快速排序是对冒泡排序的进一步优化。通过一趟排序，先将当前数组分割成两部分，一部分比记录的关键字（一般为该数组的中间一个数据）小，另一部分反之，而后再次对获得的两个部分分别进行再一次排序，直到分割的两部分数据中均只剩一个数据，则排序结束。\n稳定性：不稳定\n时间复杂度：O(nlogn),最差情况下会突变为O(n2)\n空间复杂度：O(logn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void quick(int l,int r,int a[]) { int i,j,temp,mid; i = l; j = r; mid = a[(i+j)/2]; do { while (a[i] \u0026lt; mid) i++; while (a[j] \u0026gt; mid) j--; if (i \u0026lt;= j) { temp = a[i]; a[i] = a[j]; a[j] = temp; i++; j--; } }while (i \u0026lt;= j); if (j \u0026gt; l) quick(1,j,dt); if (i \u0026lt; r) quick(i,n,dt); } 插入排序 基本思想：在数据读入的过程中，每读入一个数据，就进行一次遍历，将其放置于合适的位置中，这样数据输入完成后，数组中的数便是有序的。这种操作类似于斗地主时有的人习惯抓一张牌，整一张牌。\n稳定性：稳定\n时间复杂度：O(n2)\n空间复杂度：O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void insertion(int a[]) { for (int i=1; i\u0026lt;=n; i++) { int key = a[i]; int j = i-1; while (j\u0026gt;0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j+1] = a[j]; j--; } a[j+1] = key; } } 桶排序 基本思想：若数据存在明显的范围，那我们可以提前准备好若干个有序桶，输入数据后将其装入对应的桶中。后顺序输出各桶所对应的值（根据桶中所装数据的个数）。该排序方法对于查重有着极佳的应用性。缺点也很明显，就是必须知道数据的范围。\n稳定性：不稳定\n时间复杂度：O(n)\n空间复杂度：O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const int num = 10010; const int radius = 101; //桶的范围或个数 int dt[num],buc[radius]; int n; void bucket_init(int a[]) { for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); buc[a[i]]++; } } void bucket_print(int a[]) { for (int i=0; i\u0026lt;radius; i++) //小心i要小于radius，若桶有101个，则桶上的数值为0-100 { while (buc[i] \u0026gt; 0) { printf(\u0026#34;%d \u0026#34;,i); buc[i]--; } } cout\u0026lt;\u0026lt;endl; } 归并排序 基本思想：该算法采用了分治法，即要处理一个整体，先将整体拆分成多个部分，将各个部分分别处理后，在进行合并，最终得到所要的结果。要处理一个无序数组，将其均分为两个子序列，而后对子序列分别再均分，直到得到的子序列中仅剩一个元素，而后回溯进行排序，合并，最终得到有序的目标数列。\n稳定性：稳定\n时间复杂度：O(nlogn)\n空间复杂度：O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void merge(int l,int r,int a[]) { if (l \u0026gt;= r) return; int mid = (l+r) / 2; merge(l,mid,a); merge(mid+1,r,a); //注意右半部分的开始为mid+1 int i = l; int j = mid + 1; int k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (a[i] \u0026lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i \u0026lt;= mid) //复制左序列剩余 temp[k++] = a[i++]; while (j \u0026lt;= r) //复制右序列剩余 temp[k++] = a[j++]; for (int i=l; i\u0026lt;=r; i++) //记得复制回原数列 a[i] = temp[i]; } 拓展应用：求数组中逆数对的个数 逆数对：数组中数a排在数b的前面，但a\u0026gt;b，那么我们将(a,b)称为一个逆数对\n基本思想：假定排序过程中左数列为{4，6，8，11}，右数列为{2，3，7，9}，若右数列中的2小于左数列中的4，那么它一定与左数列中在4之后（包括4）的数构成逆数对，这样的话在排序过程中避免了一对一对的统计，从而大大提高了效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void merge(int l,int r,int a[]) { if (l \u0026gt;= r) return; int mid = (l+r) / 2; merge(l,mid,a); merge(mid+1,r,a); int i = l; int j = mid + 1; int k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (a[i] \u0026lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; ans += mid - i + 1; //ans用于记录逆数对的个数 } } while (i \u0026lt;= mid) temp[k++] = a[i++]; while (j \u0026lt;= r) temp[k++] = a[j++]; for (int i=l; i\u0026lt;=r; i++) a[i] = temp[i]; } ","date":"2023-08-02T13:40:36+08:00","permalink":"https://xiaotianmuyun1113.top/p/%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/","title":"数据排序"},{"content":"高精度计算 由于创建的变量存在空间大小的限制，若数字的位数过大，可能无法进行计算，甚至无法创建相应变量。 因此借助数组将数字的每一位单独储存，并以小学所学的竖式计算为原理进行运算。最后的结果也以数组进行储存。\n输入 输入的时候,要倒序储存，以便进位。 同时用数组的第一位来储存该数的位数，便于随时调用。\n1 2 3 4 5 6 7 8 void init(int a[]) { string s; cin\u0026gt;\u0026gt;s; a[0] = s.length(); for (int i=1; i\u0026lt;=a[0]; i++) a[i] = s[a[0]-i] - 48; } 输出 注意倒序输出\n1 2 3 4 5 6 void print(int a[]) { for (int i=a[0]; i\u0026gt;0; i--) printf(\u0026#34;%d\u0026#34;,a[i]); cout\u0026lt;\u0026lt;endl; } 加法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void add(int a[],int b[]) { int i=1,x=0; //i为当前计算的位数，x为向下一位的进位 while (i\u0026lt;=len1 || i\u0026lt;=len2) //len为两个数字的位数，要满足两者的每一位均进入计算过程 { c[i]=a[i]+b[i]+x; x=c[i]/10; //处理进位 c[i]%=10; i++; } if (x == 0) //最高位特判 { len3=i-1; return; } c[i]=x; len3=i; } 减法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void minuss(char S1[],char S2[]) { char S3[num]; if (strlen(S1)\u0026lt;strlen(S2) || (strlen(S1) == strlen(S2) \u0026amp;\u0026amp; strcmp(S1,S2)\u0026lt;0)) //strcmp()用于比较字符串大小，原理为将两个字符串同位上的字符进行ASCLL码相减，若为0则将下一位相减，结果不为0时返回相减所得值，若字符串相等则返回0. { strcpy(S3,S1); //strcpy()将函数中的后一个数组的值完全赋值给前一个数组 strcpy(S1,S2); strcpy(S2,S3); cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; } len1=strlen(S1); len2=strlen(S2); for (int i=0;i\u0026lt;=len1-1;i++) //逆序存入int数组,便于计算 a[len1-i]=int(S1[i]-48); //S1的指针从0开始,a的指针从1开始 for (int i=0;i\u0026lt;=len2-1;i++) b[len2-i]=int(S2[i]-48); int w=1; while (w\u0026lt;=len1 || w\u0026lt;=len2) { if (a[w]\u0026lt;b[w]) //不够减的话向高位借1 { a[w]+=10; a[w+1]--; } ans[w]=a[w]-b[w]; w++; } lena=w; while ((ans[lena] == 0) \u0026amp;\u0026amp; lena \u0026gt; 1) lena--; for (int i=lena;i\u0026gt;=1;i--) //注意倒序输出最后是i-- printf(\u0026#34;%d\u0026#34;,ans[i]); return; } 乘法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void chen(int a1[],int a2[]) { for (int i=1;i\u0026lt;=len1;i++) { int jw=0; //处理进位 for (int j=1;j\u0026lt;=len2;j++) { ans[i+j-1]=ans[i+j-1]+a1[i]*a2[j]+jw; //例如6*6=36中，第一步是确定个位上的6，再将3进位 jw=ans[i+j-1]/10; ans[i+j-1]%=10; //注意每一位上的数字要小于10 } ans[i+len2]+=jw; } ans[0]=len1+len2; //多位数乘多位数，结果的位数不会超过两数位数之和 while (ans[0] \u0026gt;= 1 \u0026amp;\u0026amp; ans[ans[0]] == 0) ans[0]--; //日常抹零 } 高精除以低精 1 2 3 4 5 6 7 8 9 10 11 12 void dichu(int a[],int b) { int x=0; for (int i=1; i\u0026lt;=a[0]; i++) { ans[i] = (x * 10 + a[i]) / b; x = (x * 10 + a[i]) % b; } int ans[0] = 1; while (ans[ans[0]] == 0 \u0026amp;\u0026amp; ans[0] \u0026lt;= lens) ans[0]++; } 高精除以高精 重中之重，并且是难点。 cop函数用于比较两个高精度数据的大小。 jian函数是正常的高精度减法。 gc函数是主体函数，主要思想是以减法来模拟除法，从而实现计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 int cop(int a[],int b[]) { if (a[0] \u0026lt; b[0]) return -1; else if (a[0] \u0026gt; b[0]) return 1; else { for (int i=a[0]; i\u0026gt;0; i--) { if (a[i] \u0026gt; b[i]) return 1; else if (a[i] \u0026lt; b[i]) return -1; } return 0; } } void jian(int a[],int b[]) { int flag; flag = cop(a,b); if (flag == 0) { a[0] = 0; return; } else if (flag == 1) { for (int i=1; i\u0026lt;=b[0]; i++) { if (a[i] \u0026lt; b[i]) { a[i+1]--; a[i] += 10; } a[i] -= b[i]; } while (a[0] \u0026gt; 0 \u0026amp;\u0026amp; a[a[0]] == 0) a[0]--; } return; } void gc(int a[],int b[],int c[]) { if (cop(a,b) == -1) { printf(\u0026#34;0\\n\u0026#34;); print(a); } else { int tmp[num]; c[0] = a[0] - b[0] + 1; for (int i=c[0]; i\u0026gt;0; i--) { memset(tmp,0,sizeof(tmp)); for (int j=1; j\u0026lt;=b[0]; j++) tmp[i+j-1] = b[j]; tmp[0] = b[0] + i - 1; while (cop(a,tmp) != -1) { c[i]++; jian(a,tmp); } } while (c[0] \u0026gt; 0 \u0026amp;\u0026amp; c[c[0]] == 0) c[0]--; } return; } ","date":"2023-07-21T17:24:39+08:00","permalink":"https://xiaotianmuyun1113.top/p/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AF%84%E7%AE%97/","title":"高精度寄算"},{"content":"HTML——超文本标记语言 超文本——所谓的链接\n标记（标签）：带尖括号的文本\n标签语法 格式：\u0026lt;开始标签\u0026gt; 内容 \u0026lt;结尾标签\u0026gt;\n要点：标签成对出现 \u0026lt;\u0026gt;里面放英文字母（结尾标签前面加/）\n（拓展）标签分类：双标签，单标签（只有开始标签）eg：-换行 -水平线\nhtml 基本骨架 格式 \u0026lt;html\u0026gt;：整个网页 \u0026lt;head\u0026gt;：网页头部，面向浏览器 \u0026lt;title\u0026gt;：网页标题 \u0026lt;body\u0026gt;：网页主体，面向用户 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tip VS Code中！（英文）+Enter（Tab）可自动生成骨架。\n标签的关系 作用：明确标签书写位置，让代码更整齐\n分类：父子标签（嵌套）- 子级标签换行且缩进（Tab键） 兄弟标签（并列）- 兄弟标签换行且对齐\n注释 是对代码的解释说明\n1 \u0026lt;!-- --\u0026gt; VS Code中包含有注释的快捷键。 快捷键：Ctrl + /\n标签 标题标签 符号：\u0026lt;h1~h6\u0026gt;具体内容\u0026lt;/h1~h6\u0026gt; 特点：文字加粗 字号由大到小 独占一行（换行） 其中h1标题一个网页仅限一个 段落标签 符号：\u0026lt;p\u0026gt;具体内容\u0026lt;/p\u0026gt; 特点：独占一行 段落之间自动空一行 段落相关标签 \u0026lt;br\u0026gt;——换行 \u0026lt;hr\u0026gt;——水平线，即在段与段之间插入一条实线 文本格式化标签 加粗字体 符号：\u0026lt;strong\u0026gt; \u0026lt;b\u0026gt; 倾斜 符号：\u0026lt;em\u0026gt; \u0026lt;i\u0026gt; 下划线 符号：\u0026lt;ins\u0026gt; \u0026lt;u\u0026gt; 删除线 符号：\u0026lt;del\u0026gt; \u0026lt;s\u0026gt; Tip：两种符号均可，前者在实际更常用，自带强调含义。 多属性标签 属性之间以一个空格间隔开，无先后之分。\n1 \u0026lt;img src=\u0026#34;图像的URL\u0026#34; alt=\u0026#34;\u0026#34; title=\u0026#34;\u0026#34; \u0026gt; 图像标签 符号：\u0026lt;img src=\u0026quot;图像的URL\u0026quot; \u0026gt; src用于指定图像的位置和名称，是img必须属性 属性：alt 替换文本——图片无法显示时显示的文字 title 提示文本——鼠标悬停在图片上时显示的文字 width 图片宽度——数字，无单位 height 图片高度——数字，无单位 Tip：浏览器中宽高默认等比缩放，即修改其中一个要素另一个也会改变 音频标签 符号：\u0026lt;audio src=\u0026quot;音频的URL\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt; 属性：src——必须属性，支持格式：mp3，Ogg，Wav controls——显示音频控制面板 loop——循环播放 autoplay——自动播放，一般情况下浏览器禁用自动播放 Tip：在HTML5中如果属性名和属性值完全一样，可以简写为一个单词 eg.controls=”controls” → controls 视频标签 符号：\u0026lt;video src=\u0026quot;视频的URL\u0026quot;\u0026gt;\u0026lt;/video\u0026gt; 属性：Src——必须属性，支持格式：mp4，WebM，Ogg controls——显示控制面板 loop——循环播放 muted——静音播放 autoplay——自动播放（仅在静音状态下可用，所以必须与muted一起出现） 超链接标签 作用：点击跳转到其他界面（在线or本地） 符号：\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;文字内容\u0026lt;/a\u0026gt; href——跳转地址，是必须属性 \u0026lt;a href=\u0026quot;\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;可实现新窗口跳转页面 开发初期，跳转地址未知，href属性值写#，表示空链接，点击后不会跳转 路径 相对路径 从当前文件夹出发查找目标文件 文件夹名称/——进入某个文件夹 ./——进入当前文件夹 ../——进入上一级文件夹 绝对路径 从盘符（eg：C盘）开始查找目标文件\n1 C:/images/mao.jpg windows默认显示路径时用\\表示进入文件夹，其它系统是/，建议统一写成/ 还可以引用文件的在线网址，可应用于网站的友情链接 小知识 VS Code中Alt+Z可实现文字折行。 ","date":"2023-06-15T13:39:56+08:00","permalink":"https://xiaotianmuyun1113.top/p/html5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"html5 学习笔记"}]