[{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\nwordcloud库概述 wordcloud库是优秀的词云展示第三方库\n词云是以词语为基本单位，将不同颜色，形式的文字随机排列，并按照出现顺序进行文字大小的相对安排\n词云图片可以更加直观地展示出一篇文本的重点\nwordcloud库常规用法 1 2 3 4 import wordcloud c = wordcloud.WordCloud() #创建对象 c.generate(\u0026#34;aaaaa\u0026#34;) #向对象c中加载文本txt c.to_file(\u0026#34;aaaaa.png\u0026#34;) #将词云输出为图像文件,.png或.jpg格式 对象参数配置 1 2 3 4 5 6 7 8 9 10 width #图像宽度 height #图像高度 min_font_size #最小字号 max_font_size #最大字号 font_step #字号大小步进间隔 font_path #指定字体文件的路径 max_words #词云显示单词的最大数量 stop_words #不显示的单词列表 mask #指定词云形状，需要引用imread()函数 background_color #背景颜色，默认为黑 ","date":"2023-09-24T14:32:41+08:00","permalink":"https://xiaotianmuyun1113.top/p/wordcloud%E5%BA%93/","title":"Wordcloud库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\njieba库概述 jieba库是一个优秀的中文分词第三方库\n中文文本需要通过分词才可以获得单个词语\njieba库提供了三种分词模式\njieba库利用一个中文词库来确定每个中文字符的关联概率，并以此为依据组成词语，用户还可以添加自定义的词组（jieba.add_word(w)）\njieba库的三种模式 精确模式 把文本精确地切分开，不存在冗余单词\njieba.lcut(s)\n全模式 把文本中所有可能词语都扫描出来，存在冗余\njieba.lcut(s, cut_all = True)\n搜索引擎模式 在精确模式的基础上，对长词进行再次切分\njieba.lcut_for_search(s)\n","date":"2023-09-23T09:14:08+08:00","permalink":"https://xiaotianmuyun1113.top/p/jieba%E5%BA%93/","title":"Jieba库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\npyinstaller库概述 该库的基本功能是将.py源代码转换成无需源代码的可执行文件，例如Windows的exe文件\n该库是第三方库，需要额外安装\n官方网站\n使用说明 使用pyinstaller库需要打开cmd命令行，然后输入：pyinstaller -F \u0026lt;文件名.py\u0026gt;\n1 2 3 4 5 6 # pyinstaller库的常用参数 -h #查看帮助 --clean #清理打包过程中的临时文件 -D，--onedir #默认值，生成dist文件夹 -F，--onefile #在dist文件夹中只生成独立的打包文件 -i \u0026lt;图标文件名.ico\u0026gt; #指定打包程序使用的图标(icon)文件 ","date":"2023-09-21T22:52:40+08:00","permalink":"https://xiaotianmuyun1113.top/p/pyinstaller%E5%BA%93/","title":"Pyinstaller库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\nrandom库概述 random库是用于产生随机数的python标准库\n其采用梅森旋转算法生成（伪）随机序列中的元素\n基本随机函数 1 2 seed(a = None) #初始化随机数种子，相同的种子产生的元素序列是相同的 random() #产生一个0~1之间的随机小数（不包括1） 扩展随机函数 1 2 3 4 5 6 randint(a, b) #生成一个[a, b]之间的整数 randrange(m, n[, k]) #生成一个[m, n)之间以k为步长的随机整数 getrandbits(k) #生成一个k bit长的随机整数 uniform(a, b) #生成一个[a, b]之间的随机小数 choice(a) #从序列a中随机选择一个元素 shuffle(a) #将序列a中的元素随机打乱 ","date":"2023-09-19T10:59:13+08:00","permalink":"https://xiaotianmuyun1113.top/p/random%E5%BA%93/","title":"Random库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\ntime库概述 time库是Python中用于处理时间的标准库，它可以实现时间表达，获取系统时间以及精确计时等功能\n时间获取 1 2 3 time() #获取当前时间戳，即计算机内部自带的时间值，并以浮点数形式表示 ctime() #获取当前系统时间并以人类可读的方式返回一个字符串 gmtime() #获取当前时间，并表示为计算机可处理的时间格式 时间格式化 程序计时 测量时间用到perf_counter()函数，它可以返回一个cpu级别的精确时间计数值，单位为s，但由于起点不确定，故使用时需要多次调用，通过计算差值来确定程序所用的时间\nsleep(s)函数用于控制程序的停顿，s是程序停顿的时间，单位为s，支持浮点数，运行到该函数后，程序将停顿时间s\n","date":"2023-09-19T08:37:46+08:00","permalink":"https://xiaotianmuyun1113.top/p/time%E5%BA%93/","title":"Time库"},{"content":"图片显示不出来 法1 (该部分为转载) 原文地址\n以微博作为图床，将图片通过微博发布后再拷贝其图像链接至文档即可\n具体操作：\nstep1：下载微博图床插件 下载地址\nstep2: 在浏览器中打开管理拓展，打开开发者模式，再点击加载解压缩的扩展，导入解压后的图床插件\nstep3：上微博号，打开插件即可上传图片\n如果你想删掉某一张图，点击\u0026quot;设置/历史\u0026quot;即可\n法2 将图片放在static目录下，在图片引用时要写成(/img/图片名.图片格式)\n","date":"2023-09-05T19:48:39+08:00","permalink":"https://xiaotianmuyun1113.top/p/blog%E7%BC%96%E5%86%99%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Blog编写中遇到的问题"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\nturtle库概述 turtle(海龟)库是turtle绘图体系的Python实现，是Python语言的标准库之一\nturtle库通过窗体中海龟的移动，隐藏或显示海龟的移动轨迹来进行图形的绘制，可以通过代码来改变轨迹的粗细，颜色等特性\nturtle库的绘图窗体 指令：turtle.setup(width, height, startx, starty)\n后两个参数不是必须的，若没有则窗口中心点默认置于屏幕中心点处\nturtle库的空间坐标体系 绝对坐标 即以屏幕的中心点作为坐标系的原点，然后以一个像素作为一个单位长度，以水平向右为x轴正方向，竖直向上为y轴正方向，对窗口中的每个点进行唯一确定的坐标表示\nturtle.goto(x, y)即让海龟沿直线从当前位置移动到点(X, Y)处\n海龟坐标 即以海龟头部为正方向，来进行控制\nturtle.fd(d)即让海龟前进d个像素\nturtle.bk(d)即让海龟后退d个像素\nturtle.circle(r, angle)即让海龟沿着半径为r（r为正时圆在海龟的左手边）的圆移动到距当前点angle（angle为正时即为逆时针运动）角度的点上\nturtle的角度坐标体系 绝对角度 以水平向右为0°，竖直向上为90°，对海龟头部的角度进行描述\nturtle.seth(angle)即让海龟的头部转到angle的方向上，其中angle为绝对角度，seth函数使用后海龟只转向而不行进\n海龟角度 以海龟头现方向为正方向，来描述转向\nturtle.left/right(angle)即让海龟向左/右转向angle的角度\nRGB色彩体系 RGB指的是红绿蓝三个通道的颜色组合，通过控制每个通道的参数来改变所得到的颜色，它可以覆盖视力所能感知的所有颜色\nRGB的色彩模式 turtle.colormode(mode)通过控制mode参数来改变色彩模式\n-1.0：RGB小数值模式，参数取值为0~1之间的小数(一般位两位)\n-255：RGB整数值模式，参数取值为0~255之间的整数\n画笔控制函数 turtle.penup()/turtle.pu()抬起画笔，海龟移动时不显示轨迹\nturtle.pendown()/turtle.pd()落下画笔，显示出海龟的移动轨迹\nturtle.pensize(width)/turtle.width(width)设置线条粗细\nturtle.pencolor(color)设置画笔颜色，color为颜色字符串或对应颜色的RGB值\n","date":"2023-09-02T20:20:08+08:00","permalink":"https://xiaotianmuyun1113.top/p/turtle%E5%BA%93/","title":"Turtle库"},{"content":"笔记来源 北理——Python语言程序设计\n本文内部图片大多来自课程课件，侵权请告知1979409875@qq.com\n编译和解释 编译 将源代码一次性转换成目标代码的过程\n解释 将源代码逐条转换成目标代码同时逐条执行的过程(类似同声传译)\n程序的编写方法and思想 IPO I：Input 程序的输入(文件，网络，控制台，交互界面，内部参数)\nP: Proce 对于输入数据的处理，即算法，是一个程序的灵魂所在\nO: Output 结果的输出(控制台，图形，网络，文件，内部参数)\nIPO思想是编写程序的基本思想，根据用户的输入和所需的输出，进行主体程序的设计和编写，是最简单粗暴的思路。\n代码复用 将代码看作一种可以重复使用，互相共享的“资源”。\n代码抽象化：使用函数，对象等方法对代码赋予更高级别的定义\n模块化设计 通过函数或对象封装将程序划分为模块及模块间的表达，然后通过各个模块之间的相互配合完成主任务\n程序部分间的关系分为紧耦合和松耦合两种，模块内部应紧耦合，模块之间应松耦合\npython开发环境 python基本开发环境IDLE python官方提供，适用于小规模程序开发\n优点：轻量级，使用灵活；功能丰富，拥有众多标准库以及第三方库可供使用。\n下载地址\npython高级开发环境VSCode 配置该环境时要先布局IDLE，后下载VSCode下载地址\npython的计算生态 标准库+第三方库\n标准库：随解释器直接安装到操作系统中的功能模块\n第三方库：需要经过安装才能使用的功能模块\n两种编程方式 交互式：对每个输入语句立即运行结果\n文件式：代码在py文件中编写完成后一次性进行运行，是编程的主要方式\n程序的格式框架 缩进：一行代码开始前的空白部分，用于指出程序的层次结构；是语法的一部分，缩进错误程序也会报错；一个程序中的缩进一般一致，统一为1个Tab或4个空格\n注释：不被程序执行的辅助性文字，用于提高代码的可读性；若单行则以#开头，若多行则以\u0026rsquo;\u0026lsquo;\u0026lsquo;开头和结尾\n命名与保留字 变量：程序中用于保存和表示数据的占位符号\n命名：用=将变量和标识符关联起来的过程，命名要遵循许多规则，如：可为大小写字母，数字，下划线和中文字符或其组合；大小写敏感；首字符不能为数字；不与保留字相同\n保留字：被编程语言内部定义并保留使用的标识符。python中有35个保留字，它们分别为以下图片中所示\n库引用 使用import保留字完成引用\n基本用法：import\u0026lt;库名\u0026gt;\n\u0026lt;库名\u0026gt;.\u0026lt;函数名\u0026gt;(\u0026lt;函数参数\u0026gt;)\n拓展用法 1.from \u0026lt;库名\u0026gt; import \u0026lt;函数名\u0026gt;\n2.from \u0026lt;库名\u0026gt; import*\n\u0026lt;函数名\u0026gt;(\u0026lt;函数参数\u0026gt;)\n此种方法会出现函数重名的问题\n3.import \u0026lt;库名\u0026gt; as \u0026lt;库别名\u0026gt;\n\u0026lt;库别名\u0026gt;.\u0026lt;函数名\u0026gt;(\u0026lt;函数参数\u0026gt;)\n此种方法适用于外部库的原库名较为繁琐的情况，可以达到提高编程效率的效果\n数字类型 整数类型 可正可负，无取值范围的限制\n拥有多种进制；其中二进制以0b或0B开头，八进制以0o或0O开头，十六进制以0x或0X开头\nint(x) 可将x转化为整数类型，同时直接舍弃小数部分\n浮点数类型 它与数学中实数的概念相同\n浮点数的取值范围与小数精度都存在限制。取值范围数量级约为±10的307次方，而精度数量级为10的-16次方。\nfloat(x) 可将x转化为浮点数类型\n由于浮点数类型以53位二进制表示小数部分，故两个浮点数运算过程中存在不确定尾数，导致结果与真实值不同，可以用round()函数进行四舍五入\n浮点数类型可以采用科学计数法来表示，使用e或E来作为幂的符号，以10为基数\n1 \u0026lt;a\u0026gt;e\u0026lt;b\u0026gt; #表示 a*10的b次方 复数类型 与数学中复数的概念一致\neg. z = 1.23e-4 + 5.6e + 89j\ncomplex(x) 可将x转化为复数，增加虚数部分\n1 2 z.real() #获得实部 z.imag() #获得虚部 数值运算 数值运算操作符 1 2 3 4 5 6 7 8 9 x + y x - y x * y x / y #x与y的商，结果是浮点数 x // y #x与y的整数商，结果是整数 + x #表示x本身 - x #表示x的相反数 x % y #表示x除以y后的余数 x ** y #表示幂运算，与pow()函数效果相似 二元操作增强赋值操作符\n数值运算函数 1 2 3 4 5 6 pow(x, y[, z]) #计算x的y次方，而后再将结果与z取余，参数z可省略 round(x, d) #将x四舍五入至小数点后d位，d可省略，其默认值为0 abs(x) #取x的绝对值 divmod(x, y) #同时输出 x//y 与 x%y 的结果 max(......) #返回括号中数值的最大值 min(......) #返回括号中数值的最小值 数字类型关系 不同数字类型间可以进行混合运算，生成“最宽”的类型\n整数 \u0026lt; 浮点数 \u0026lt; 复数\n字符串类型 由0个或多个字符组成的有序字符序列，在最外围被一对单引号或双引号包裹\n由一对单引号或双引号只可表示单行字符串，而由一对三单引号或三双引号可以表示多行字符串\n字符串中每一个元素的位置有两种序号表示，分别为正向递增序列（从左侧起由0开始定位）和反向递减序列（从右侧起由-1开始定位）\n字符串的使用 索引：返回字符串中单个字符 \u0026lt;字符串\u0026gt;[M]\n切片：返回字符串中一段字符子串 \u0026lt;字符串\u0026gt;[M:N:K]（其中K表示步长，K值为-1时表示对字符串进行逆序输出）\n转义符（\\） 转义符的使用可以使特定字符失去原来的特殊功能，而表达其字符的本意\n转义符还可以与一些字母进行搭配使用，从而表达一些不可打印的含义，如：\u0026quot;\\b\u0026quot;表示回退，\u0026quot;\\n\u0026quot;表示换行，即光标移动到下行首，\u0026quot;\\r\u0026quot;表示回车，即光标移动到本行首\n字符串操作符 字符串处理函数 1 2 3 4 5 6 len(x) #返回字符串x的长度 str(x) #将任意类型的x转换为字符串形式 hex(x) #表示整数x的十六进制小写形式字符串 oct(x) #表示整数x的八进制小写形式字符串 chr(x) #返回Unicode编码x所对应的字符 ord(x) #返回字符x所对应的Unicode编码 字符串处理方法 字符串类型的格式化 字符串格式化用到.format()方法\n\u0026lt;模板字符串\u0026gt;.format(\u0026lt;逗号分隔的参数\u0026gt;)\n组合数据类型 集合类型 集合定义 集合是多个元素的无序组合\n与数学中的集合概念一致，集合中的元素存在无序性，互异性，确定性\n因为要保证集合中的每个元素都唯一确定，故集合中的元素不可更改\n集合用大括号{}来表示，集合内的元素用逗号来分隔\n建立集合类型可用{}或set()函数，但建立空集合时，必须使用set()函数\n集合操作符 1 2 3 4 5 6 7 8 9 10 11 # 6个操作符 S | T #集合S与集合T取并集 S \u0026amp; T #集合S与集合T取交集 S - T #集合S去掉与集合T所拥有的相同元素后形成的集合 S ^ T #集合S与集合T的并集减去交集后的集合 S \u0026lt; T / S \u0026gt; T #用于判断S和T的子集或包含关系，返回值为True或False # 4个增强操作符 S |= T S -= T S \u0026amp;= T S ^= T 集合的处理方法 1 2 3 4 5 6 7 8 9 10 S.add(x) #若x不在S中，将x增加到S中 S.discard(x) #移除S中元素x，若x not in S，不报错 S.remove(x) #移除S中元素x，若x not in S，产生KeyError异常 S.clear() #移除S中所有元素 S.pop() #随机取出S中的一个元素，若S为空则产生KeyError异常 S.copy() #产生集合S的一个副本 len(S) #返回S的元素个数 x in S #判断S中元素x是否存在 x not in S #判断x是否不存在于S中 set(x) #将其他类型变量x转变为集合类型 集合类型应用 包含关系的比较，数据去重（由于集合中的元素具有互异性）\n序列类型 序列定义 序列类型是具有先后关系的一组元素，元素间由序号引导，通过下标访问特定的元素\n序列类型中的下标有两种，分别为正向递增序号（从0开始）和反向递减序号（从-1开始）\n序列中的元素类型可以不相同，如字符串类型和整数类型可以同时存在于一个序列中\n序列处理函数和方法 1 2 3 4 5 6 7 8 9 10 11 12 13 #操作符 x in s x not in s s + t #连接两个序列s和t s * n/n * s #将序列s复制n次 s[i] #索引，返回s中的第i个元素 s[i:j]/s[i:j:k] #切片，返回s中第i到j以k为步长的元素子序列 #函数和方法 len(s) #返回s的元素个数 min(s) #返回s中的最小元素，s中的元素需要可比较 max(s) s.index(x)/s.index(x, i, j) #返回序列s从第i位到第j位中x第一次出现的位置 s.count(x) #返回序列s中x的出现次数 元组类型 元组定义 元组类型是序列类型的一种扩展，和集合类似，一旦创建后就不能被修改\n使用小括号() 或 tuple()函数来创建，元素之间要用逗号分隔开来\n元组类型的操作与序列类型的操作基本相同\n若不希望数据被改变，可将数据转化为元组类型\n列表类型 列表定义 列表类型也是序列类型的一种扩展，与元组不同，它创建后可以随意修改\n使用方括号[] 或 list()创建，元素间用逗号分隔\n列表中的各元素类型可以不同，无长度限制\n列表类型的操作函数和方法 1 2 3 4 5 6 7 8 9 10 11 12 13 ls[i] = x #替换ls中第i位元素为x ls[i:j:k] = lt #用lt替换ls切片后的子列表 del ls[i] #删除第i位元素 del ls[i:j:k] #删除ls中第i到第j以k为步长的元素 ls += lt #将lt中的元素增加到ls中 ls *= n #将ls中的元素重复n次 ls.append(x) #在ls最后增加元素x ls.clear() #清空列表ls ls.copy() #生成与ls相同的一个新列表 ls.insert(i,x) #在ls的第i位增加新元素x ls.pop(i) #将第i位元素取出并删除 ls.remove(x) #将ls中出现的第一个x删除 ls.reverse() #将ls中的元素反转 字典类型 字典定义 要使用字典类型，首先要理解“映射”\n映射是一种键（索引）和值（数据）的对应，就像取快递时，根据快递单号能够找到自己的快递一样\n字典类型是“映射”的具体体现，它是键值对的集合，键值对之间没有顺序\n采用大括号{} 或 dict()创建，键值对用冒号表示\n字典类型的用法 1 2 3 4 \u0026lt;字典变量\u0026gt; = {\u0026lt;键1\u0026gt;:\u0026lt;值1\u0026gt;, ... , \u0026lt;键n\u0026gt;:\u0026lt;值n\u0026gt;} \u0026lt;值\u0026gt; = \u0026lt;字典变量\u0026gt;[\u0026lt;键\u0026gt;] \u0026lt;字典变量\u0026gt;[\u0026lt;键\u0026gt;] = \u0026lt;值\u0026gt; #[]用来向字典变量中索引或增加元素 字典处理函数和方法 1 2 3 4 5 6 7 8 9 10 del d[k] #删除d中键k对应的数据值 k in d #判断k是否在d中 d.keys() #返回字典d中所有键信息 d.values() #返回字典d中所有的值信息 d.items() #返回所有键值对信息 d.get(k, \u0026lt;default\u0026gt;) #若键k存在，则返回对应值，不存在则返回\u0026lt;default\u0026gt;值 d.pop(k, \u0026lt;default\u0026gt;) #若键k存在，则取出对应值（返回加将其从字典中删除），不存在则返回\u0026lt;default\u0026gt;值 d.popitem() #随机取出d中的一个键值对，并以元组形式返回 d.clear() #清空字典 len(d) #返回d中的元素个数 程序的结构 程序的分支结构 if系列语句 if系列语句是用于控制程序分支结构的语句，if语句可以单独使用，构成单分支结构，还可以与else，elif配合使用，构成二分支结构，多分支结构 条件判断及组合 条件判断主要用\u0026gt;,\u0026lt;,=等操作符来体现，其中相等用==来表示，不相等用!=来表示\n条件组合用and，or，not三个保留字来表示，x and y表示x和y需要同时满足该语句才为真，x or y表示x与y满足一个整条语句就为真，not x表示x为假时该语句才为真\n程序的异常处理 用try和except关键字来进行异常处理 程序的循环结构 按照一定次数或条件执行的一组语句\nfor循环（遍历循环） 由保留字for和in构成，完整遍历所有元素后结束\n1 2 for \u0026lt;变量\u0026gt; in \u0026lt;遍历结构\u0026gt;: \u0026lt;被循环执行的语句\u0026gt; 遍历结构可以是字符串，列表，文件等等，每次循环都从结构中获取一个元素放入循环的变量当中\nfor循环常常与range()函数搭配使用\n1 2 for \u0026lt;变量\u0026gt; in range(\u0026lt;次数\u0026gt;): \u0026lt;被循环执行的语句\u0026gt; range(M,N,K)产生M~N-1之间，步长为K的整数序列，其中M，K可省略\nwhile循环（无限循环） 由while关键字构成的循环，每次执行循环的时候都会判断条件是否成立，条件不成立时循环立刻结束\n1 2 while \u0026lt;条件\u0026gt;: \u0026lt;语句块\u0026gt; 循环控制保留字 break保留字表示跳出并结束当前整个循环，执行循环后的语句（tip：break保留字仅会跳出当前层循环，多层循环时不会直接结束整个多重循环）\ncontinue保留字表示结束当次循环，继续进行下一个循环\n循环的高级用法 循环可以与else关键字结合使用，当循环没有被break语句退出时，执行else语句块，可以将其看作“正常”完成循环的奖励 函数 定义：一段具有特定功能的，可以复用的语句组\n作用：降低编程难度和积累复用代码，提高工作效率\n1 2 3 def \u0026lt;函数名\u0026gt;(\u0026lt;参数(0个或多个)\u0026gt;): #可以没有参数，但一定要保留括号 \u0026lt;函数主体\u0026gt; return \u0026lt;返回值\u0026gt; #可以不提供返回值 函数只有通过调用以后才会运行，不调用时程序执行时不会运行函数部分\n关于参数 可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数，一般置于非可选参数的后面\n可变参数传递：\n1 2 3 def \u0026lt;函数名\u0026gt;(\u0026lt;参数\u0026gt;, *b): #*b为可变参数，即不确定参数的总数量 \u0026lt;函数体\u0026gt; return \u0026lt;返回值\u0026gt; 参数传递可按照位置或名称两种方式传递\n变量 规则1 程序中的变量分为两种，一种为局部变量，即在函数内部进行定义的变量；另一种是全局变量，即在主程序中定义的变量\n局部变量在函数执行结束后便被释放，而全局变量在程序执行过程中\n规则2 若想在函数内部使用全局变量，需要使用global保留字对变量进行声明\n规则3 局部变量为组合数据类型且在函数中未真实创建时，视为全局变量\n方法 “方法”特指\u0026quot;\u0026lt;a\u0026gt;.\u0026lt;b\u0026gt;()\u0026ldquo;风格中的函数\u0026rdquo;\u0026lt;b\u0026gt;()\u0026quot;\n方法本身也是函数的一种，但其特殊地与\u0026lt;a\u0026gt;相关\nlambda函数 lambda函数是一种匿名函数，即该函数无函数名，使用lambda保留字定义，函数名是返回的结果\n该函数大多用于定义简单的，能够在一行内表示的函数 该函数应谨慎使用，它主要被用作一些特定函数或方法的参数\n函数递归 函数定义中调用函数自身的方式\n函数递归主要有两个关键特征：链条和基例\n链条就是计算过程中两个元素之间存在的关系，类似的例子就像等差数列相邻项的公差；基例就是递归函数中不需要再次递归的部分，运算过程中的其他部分是基于它（们）与链条推导出来的\n函数递归的实现要依靠分支语句的帮助\n基本实例：斐波那契序列，汉诺塔\n文件操作 文件的类型 文件是数据的抽象和集合，一共有两种展现形态，分别为文本文件和二进制文件\n本质上两种文件都是采用二进制形式储存，只是展示形式不同而已\n文本文件是由单一特定编码（如UTF-8）组成的文件，由于存在编码，故可视作存储着的长字符串，适用于txt，py等\n二进制文件直接由比特0和1组成，没有统一字符编码，适用于png，avi等\n文件的打开和关闭 文件的打开\n\u0026lt;变量名\u0026gt; = open(\u0026lt;文件名（包括文件路径和名称）\u0026gt;, \u0026lt;打开模式\u0026gt;)\n文件路径是文件在计算机中储存的位置，包括相对路径和绝对路径\n关闭文件用到\u0026lt;变量名\u0026gt;.close()函数\n文件内容的读取 1 2 3 \u0026lt;f\u0026gt;.read(size = -1) #读入全部内容，若给出参数则读入前size长度 \u0026lt;f\u0026gt;.readline(size = -1) #读入一行内容，若给出参数则该行读入前size长度 \u0026lt;f\u0026gt;.readlines(hint = -1) #读入文件所有行，以每行为元素形成列表，若给出参数则读入前hint行 文件内容的写入 1 2 3 \u0026lt;f\u0026gt;.write(s) #向文件写入一个字符串或字节流 \u0026lt;f\u0026gt;.writelines(lines) #将一个元素全为字符串的列表写入文件 \u0026lt;f\u0026gt;.seek(offset) #改变当前文件操作的指针的位置，offset值不同表示的位置也不一样，0-文件开头，1-当前位置，2-文件结尾 CSV数据储存格式 这是国际通用的一二维数据储存格式，一般以.csv为扩展名\n每行一个一维数据，采用（英文半角）逗号分隔，无空行。如果某个元素缺失，逗号仍然要保留\nExcel和一般的编辑软件都可以读入或另存为csv文件\n","date":"2023-09-02T13:12:23+08:00","permalink":"https://xiaotianmuyun1113.top/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Python基础语法"},{"content":"数据排序 数据获取后，要对所得的数据进行简单加工处理，使原本杂乱的数据变得有序，便于后续的利用。\n选择排序 基本思想：从未排序的数据中挑出一个最大的（或最小的）数据，后将其放到数列的最前端，重复该操作，最终得到排好序的数列。\n稳定性：不稳定（即非相邻两个数据间的交换会改变相同数据的先后关系）\n时间复杂度：O(n2)（即一组个数为n的数据，排序的主体操作进行的次数要达n的平方次）\n空间复杂度：O(1)（即除了储存数据所用的空间外，无需其他辅助空间）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void selection(int a[]) { int temp = 0; for (int i=1; i\u0026lt;n; i++) //最小值存放的位置 { int k = i; //当前最小值 for (int j=i+1; j\u0026lt;=n; j++) if (a[j] \u0026lt; a[k]) k = j; if (k != i) //交换过程 { temp = a[i]; a[i] = a[k]; a[k] = temp; } } } 冒泡排序 基本思想：从数组中的第一个数开始，将其与后一个数进行比较，若后一个数比前一个数小（或大），就将两个数进行交换。经过n次遍历后，即可得到数据从小到大（或从大到小）排列的数组。\n排序的优化：若其中一次遍历结束后，数组中的数没有发生交换，说明排序提前完成，此时可中断排序，节省时间。\n稳定性：稳定\n时间复杂度：O(n2)\n空间复杂度：O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void bubble(int a[]) { bool ok; for (int i=n; i\u0026gt;1; i--) { ok = false; //判断是否发生过交换 for (int j=1; j\u0026lt;i; j++) { if (a[j] \u0026gt; a[j+1]) { swap(a[j],a[j+1]); ok = true; } } if (ok == false) break; //若该次循环内没有发生交换，则排序完成，无需继续循环。 } } 快速排序 基本思想：快速排序是对冒泡排序的进一步优化。通过一趟排序，先将当前数组分割成两部分，一部分比记录的关键字（一般为该数组的中间一个数据）小，另一部分反之，而后再次对获得的两个部分分别进行再一次排序，直到分割的两部分数据中均只剩一个数据，则排序结束。\n稳定性：不稳定\n时间复杂度：O(nlogn),最差情况下会突变为O(n2)\n空间复杂度：O(logn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void quick(int l,int r,int a[]) { int i,j,temp,mid; i = l; j = r; mid = a[(i+j)/2]; do { while (a[i] \u0026lt; mid) i++; while (a[j] \u0026gt; mid) j--; if (i \u0026lt;= j) { temp = a[i]; a[i] = a[j]; a[j] = temp; i++; j--; } }while (i \u0026lt;= j); if (j \u0026gt; l) quick(1,j,dt); if (i \u0026lt; r) quick(i,n,dt); } 插入排序 基本思想：在数据读入的过程中，每读入一个数据，就进行一次遍历，将其放置于合适的位置中，这样数据输入完成后，数组中的数便是有序的。这种操作类似于斗地主时有的人习惯抓一张牌，整一张牌。\n稳定性：稳定\n时间复杂度：O(n2)\n空间复杂度：O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void insertion(int a[]) { for (int i=1; i\u0026lt;=n; i++) { int key = a[i]; int j = i-1; while (j\u0026gt;0 \u0026amp;\u0026amp; a[j] \u0026gt; key) { a[j+1] = a[j]; j--; } a[j+1] = key; } } 桶排序 基本思想：若数据存在明显的范围，那我们可以提前准备好若干个有序桶，输入数据后将其装入对应的桶中。后顺序输出各桶所对应的值（根据桶中所装数据的个数）。该排序方法对于查重有着极佳的应用性。缺点也很明显，就是必须知道数据的范围。\n稳定性：不稳定\n时间复杂度：O(n)\n空间复杂度：O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const int num = 10010; const int radius = 101; //桶的范围或个数 int dt[num],buc[radius]; int n; void bucket_init(int a[]) { for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); buc[a[i]]++; } } void bucket_print(int a[]) { for (int i=0; i\u0026lt;radius; i++) //小心i要小于radius，若桶有101个，则桶上的数值为0-100 { while (buc[i] \u0026gt; 0) { printf(\u0026#34;%d \u0026#34;,i); buc[i]--; } } cout\u0026lt;\u0026lt;endl; } 归并排序 基本思想：该算法采用了分治法，即要处理一个整体，先将整体拆分成多个部分，将各个部分分别处理后，在进行合并，最终得到所要的结果。要处理一个无序数组，将其均分为两个子序列，而后对子序列分别再均分，直到得到的子序列中仅剩一个元素，而后回溯进行排序，合并，最终得到有序的目标数列。\n稳定性：稳定\n时间复杂度：O(nlogn)\n空间复杂度：O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void merge(int l,int r,int a[]) { if (l \u0026gt;= r) return; int mid = (l+r) / 2; merge(l,mid,a); merge(mid+1,r,a); //注意右半部分的开始为mid+1 int i = l; int j = mid + 1; int k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (a[i] \u0026lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i \u0026lt;= mid) //复制左序列剩余 temp[k++] = a[i++]; while (j \u0026lt;= r) //复制右序列剩余 temp[k++] = a[j++]; for (int i=l; i\u0026lt;=r; i++) //记得复制回原数列 a[i] = temp[i]; } 拓展应用：求数组中逆数对的个数 逆数对：数组中数a排在数b的前面，但a\u0026gt;b，那么我们将(a,b)称为一个逆数对\n基本思想：假定排序过程中左数列为{4，6，8，11}，右数列为{2，3，7，9}，若右数列中的2小于左数列中的4，那么它一定与左数列中在4之后（包括4）的数构成逆数对，这样的话在排序过程中避免了一对一对的统计，从而大大提高了效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void merge(int l,int r,int a[]) { if (l \u0026gt;= r) return; int mid = (l+r) / 2; merge(l,mid,a); merge(mid+1,r,a); int i = l; int j = mid + 1; int k = l; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (a[i] \u0026lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; ans += mid - i + 1; //ans用于记录逆数对的个数 } } while (i \u0026lt;= mid) temp[k++] = a[i++]; while (j \u0026lt;= r) temp[k++] = a[j++]; for (int i=l; i\u0026lt;=r; i++) a[i] = temp[i]; } ","date":"2023-08-02T13:40:36+08:00","permalink":"https://xiaotianmuyun1113.top/p/%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/","title":"数据排序"},{"content":"参考书籍 北京邮电大学出版社 《计算机软件基础》 秦金磊，李整编著\nWhat\u0026rsquo;s 编译器 在计算机中，使用高级语言（如python、c++等）写出来的源程序，无法被计算机直接识别，高级语言必须经过翻译变成机器语言后才可被计算机所执行。这时候就要用到翻译器。而翻译器对高级语言翻译的方式一共有两种，分别为编译和解释，对应的翻译程序便称为编译器和翻译器。\n高级语言的编译过程可以由下图展示出来\n编译器的工作原理 编译器的基本工作过程包括六大步骤\n步骤一：词法分析 编译器会逐行扫描源代码，并识别符号串，主要为关键字、字面量、标识符（变量名和数据名）、运算符、注释、以及其他的特殊符号等。符号串会根据自身类别被归类并等待下一步的处理。\n例如，语句 a = b + c/2中，编译器将语句读入后将会得到记号流 a(id1), =, b(id2), +, c(id3), /, 2。其中分别使用id1，id2，id3来表示实型变量a、b、c，语句中间的空格被省略。\n步骤二：语法分析 得到记号流后，编译器中的语法分析器会将其分解成语法短语，如“程序”、“语句”、“表达式”等。这些语法短语可以表示成语法分析树。后根据所用语言的语法对每个分析树进行检查，若合法便以内部格式将其存起来。\n步骤三：语义分析 语义分析的主要内容包括以下几个方面：运算符两端的类型是否兼容、该将哪些数据进行类型转换、是否控制转移到不该去的地方、是否存在重名或语义模糊的记号。如果存在上述问题则会进行处理，反之产生中间代码。\n例如，步骤一中的那个例子中，a、b、c都是实型变量，而2是整型常量，在运算过程中需要将2转化为实型变量，再进行运算。\n步骤四：生成中间代码 中间代码是源代码向目标代码转换过程中的一种过渡编码。其形式会尽可能与机器的汇编语言相似，从而有利于下一步代码的生成。采用中间代码的好处之一是可以再中间代码上进行代码优化。\n很多编译程序生成的中间代码采用的是“四元式”的结构，四元分别为运算符、运算对象1、运算对象2、结果。eg. (* a1 a2 t1)，将a1与a2相乘，后将结果储存到t1。\n步骤五：代码优化 代码优化阶段是通过改进中间代码，以便产生具有运行更快、占用空间更小等优点的目标码。\n代码优化分为局部优化和全局优化。局部优化包括合并冗余操作，简化计算等，如以“清零”的指令替换掉“x=0”这一赋值指令。而全局优化包括改进循环，减少调用次数，快速地址算法等。\n不同的编译器对于中间代码的优化程度和优化效率各不相同。能完成大部分优化的编译器称为优化编译器。但优化过程会在一定程度上影响编译的速度，有时候简单的优化也可能让程序最后的效率大大提高，同时降低编译速度下降的幅度。\n步骤六：代码生成 由代码生成器来生成目标机器的汇编程序，其中要完成数据分段、选定寄存器等工作，然后再生成机器可执行的代码。此过程中的一个关键问题是寄存器的分配。\n1 2 3 4 5 6 //例： MOV R2, id3 //将id3放入寄存器R2 MUL R2, #60.0 //将R2与60.0相乘，结果仍储存在R2。其中的#表示60.0作为立即数处理，无需将其定义命名 MOV R1, id2 //将id2放入寄存器R1 ADD R1, R2 //将R1与R2相加，并将结果储存于R1中 MOV id1, R1 //将R1中的值传递给id1 ","date":"2023-07-21T17:24:39+08:00","permalink":"https://xiaotianmuyun1113.top/p/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","title":"编译器的工作原理"},{"content":"高精度计算 由于创建的变量存在空间大小的限制，若数字的位数过大，可能无法进行计算，甚至无法创建相应变量。 因此借助数组将数字的每一位单独储存，并以小学所学的竖式计算为原理进行运算。最后的结果也以数组进行储存。\n输入 输入的时候,要倒序储存，以便进位。 同时用数组的第一位来储存该数的位数，便于随时调用。\n1 2 3 4 5 6 7 8 void init(int a[]) { string s; cin\u0026gt;\u0026gt;s; a[0] = s.length(); for (int i=1; i\u0026lt;=a[0]; i++) a[i] = s[a[0]-i] - 48; } 输出 注意倒序输出\n1 2 3 4 5 6 void print(int a[]) { for (int i=a[0]; i\u0026gt;0; i--) printf(\u0026#34;%d\u0026#34;,a[i]); cout\u0026lt;\u0026lt;endl; } 加法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void add(int a[],int b[]) { int i=1,x=0; //i为当前计算的位数，x为向下一位的进位 while (i\u0026lt;=len1 || i\u0026lt;=len2) //len为两个数字的位数，要满足两者的每一位均进入计算过程 { c[i]=a[i]+b[i]+x; x=c[i]/10; //处理进位 c[i]%=10; i++; } if (x == 0) //最高位特判 { len3=i-1; return; } c[i]=x; len3=i; } 减法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void minuss(char S1[],char S2[]) { char S3[num]; if (strlen(S1)\u0026lt;strlen(S2) || (strlen(S1) == strlen(S2) \u0026amp;\u0026amp; strcmp(S1,S2)\u0026lt;0)) //strcmp()用于比较字符串大小，原理为将两个字符串同位上的字符进行ASCLL码相减，若为0则将下一位相减，结果不为0时返回相减所得值，若字符串相等则返回0. { strcpy(S3,S1); //strcpy()将函数中的后一个数组的值完全赋值给前一个数组 strcpy(S1,S2); strcpy(S2,S3); cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; } len1=strlen(S1); len2=strlen(S2); for (int i=0;i\u0026lt;=len1-1;i++) //逆序存入int数组,便于计算 a[len1-i]=int(S1[i]-48); //S1的指针从0开始,a的指针从1开始 for (int i=0;i\u0026lt;=len2-1;i++) b[len2-i]=int(S2[i]-48); int w=1; while (w\u0026lt;=len1 || w\u0026lt;=len2) { if (a[w]\u0026lt;b[w]) //不够减的话向高位借1 { a[w]+=10; a[w+1]--; } ans[w]=a[w]-b[w]; w++; } lena=w; while ((ans[lena] == 0) \u0026amp;\u0026amp; lena \u0026gt; 1) lena--; for (int i=lena;i\u0026gt;=1;i--) //注意倒序输出最后是i-- printf(\u0026#34;%d\u0026#34;,ans[i]); return; } 乘法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void chen(int a1[],int a2[]) { for (int i=1;i\u0026lt;=len1;i++) { int jw=0; //处理进位 for (int j=1;j\u0026lt;=len2;j++) { ans[i+j-1]=ans[i+j-1]+a1[i]*a2[j]+jw; //例如6*6=36中，第一步是确定个位上的6，再将3进位 jw=ans[i+j-1]/10; ans[i+j-1]%=10; //注意每一位上的数字要小于10 } ans[i+len2]+=jw; } ans[0]=len1+len2; //多位数乘多位数，结果的位数不会超过两数位数之和 while (ans[0] \u0026gt;= 1 \u0026amp;\u0026amp; ans[ans[0]] == 0) ans[0]--; //日常抹零 } 高精除以低精 1 2 3 4 5 6 7 8 9 10 11 12 void dichu(int a[],int b) { int x=0; for (int i=1; i\u0026lt;=a[0]; i++) { ans[i] = (x * 10 + a[i]) / b; x = (x * 10 + a[i]) % b; } int ans[0] = 1; while (ans[ans[0]] == 0 \u0026amp;\u0026amp; ans[0] \u0026lt;= lens) ans[0]++; } 高精除以高精 重中之重，并且是难点。 cop函数用于比较两个高精度数据的大小。 jian函数是正常的高精度减法。 gc函数是主体函数，主要思想是以减法来模拟除法，从而实现计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 int cop(int a[],int b[]) { if (a[0] \u0026lt; b[0]) return -1; else if (a[0] \u0026gt; b[0]) return 1; else { for (int i=a[0]; i\u0026gt;0; i--) { if (a[i] \u0026gt; b[i]) return 1; else if (a[i] \u0026lt; b[i]) return -1; } return 0; } } void jian(int a[],int b[]) { int flag; flag = cop(a,b); if (flag == 0) { a[0] = 0; return; } else if (flag == 1) { for (int i=1; i\u0026lt;=b[0]; i++) { if (a[i] \u0026lt; b[i]) { a[i+1]--; a[i] += 10; } a[i] -= b[i]; } while (a[0] \u0026gt; 0 \u0026amp;\u0026amp; a[a[0]] == 0) a[0]--; } return; } void gc(int a[],int b[],int c[]) { if (cop(a,b) == -1) { printf(\u0026#34;0\\n\u0026#34;); print(a); } else { int tmp[num]; c[0] = a[0] - b[0] + 1; for (int i=c[0]; i\u0026gt;0; i--) { memset(tmp,0,sizeof(tmp)); for (int j=1; j\u0026lt;=b[0]; j++) tmp[i+j-1] = b[j]; tmp[0] = b[0] + i - 1; while (cop(a,tmp) != -1) { c[i]++; jian(a,tmp); } } while (c[0] \u0026gt; 0 \u0026amp;\u0026amp; c[c[0]] == 0) c[0]--; } return; } ","date":"2023-07-21T17:24:39+08:00","permalink":"https://xiaotianmuyun1113.top/p/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AF%84%E7%AE%97/","title":"高精度寄算"},{"content":"HTML——超文本标记语言 超文本——所谓的链接\n标记（标签）：带尖括号的文本\n标签语法 格式：\u0026lt;开始标签\u0026gt; 内容 \u0026lt;结尾标签\u0026gt;\n要点：标签成对出现 \u0026lt;\u0026gt;里面放英文字母（结尾标签前面加/）\n（拓展）标签分类：双标签，单标签（只有开始标签）eg：-换行 -水平线\nhtml 基本骨架 格式 \u0026lt;html\u0026gt;：整个网页 \u0026lt;head\u0026gt;：网页头部，面向浏览器 \u0026lt;title\u0026gt;：网页标题 \u0026lt;body\u0026gt;：网页主体，面向用户 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tip VS Code中！（英文）+Enter（Tab）可自动生成骨架。\n标签的关系 作用：明确标签书写位置，让代码更整齐\n分类：父子标签（嵌套）- 子级标签换行且缩进（Tab键） 兄弟标签（并列）- 兄弟标签换行且对齐\n注释 是对代码的解释说明\n1 \u0026lt;!-- --\u0026gt; VS Code中包含有注释的快捷键。 快捷键：Ctrl + /\n标签 标题标签 符号：\u0026lt;h1~h6\u0026gt;具体内容\u0026lt;/h1~h6\u0026gt; 特点：文字加粗 字号由大到小 独占一行（换行） 其中h1标题一个网页仅限一个 段落标签 符号：\u0026lt;p\u0026gt;具体内容\u0026lt;/p\u0026gt; 特点：独占一行 段落之间自动空一行 段落相关标签 \u0026lt;br\u0026gt;——换行 \u0026lt;hr\u0026gt;——水平线，即在段与段之间插入一条实线 文本格式化标签 加粗字体 符号：\u0026lt;strong\u0026gt; \u0026lt;b\u0026gt; 倾斜 符号：\u0026lt;em\u0026gt; \u0026lt;i\u0026gt; 下划线 符号：\u0026lt;ins\u0026gt; \u0026lt;u\u0026gt; 删除线 符号：\u0026lt;del\u0026gt; \u0026lt;s\u0026gt; Tip：两种符号均可，前者在实际更常用，自带强调含义。 多属性标签 属性之间以一个空格间隔开，无先后之分。\n1 \u0026lt;img src=\u0026#34;图像的URL\u0026#34; alt=\u0026#34;\u0026#34; title=\u0026#34;\u0026#34; \u0026gt; 图像标签 符号：\u0026lt;img src=\u0026quot;图像的URL\u0026quot; \u0026gt; src用于指定图像的位置和名称，是img必须属性 属性：alt 替换文本——图片无法显示时显示的文字 title 提示文本——鼠标悬停在图片上时显示的文字 width 图片宽度——数字，无单位 height 图片高度——数字，无单位 Tip：浏览器中宽高默认等比缩放，即修改其中一个要素另一个也会改变 音频标签 符号：\u0026lt;audio src=\u0026quot;音频的URL\u0026quot;\u0026gt;\u0026lt;/audio\u0026gt; 属性：src——必须属性，支持格式：mp3，Ogg，Wav controls——显示音频控制面板 loop——循环播放 autoplay——自动播放，一般情况下浏览器禁用自动播放 Tip：在HTML5中如果属性名和属性值完全一样，可以简写为一个单词 eg.controls=”controls” → controls 视频标签 符号：\u0026lt;video src=\u0026quot;视频的URL\u0026quot;\u0026gt;\u0026lt;/video\u0026gt; 属性：Src——必须属性，支持格式：mp4，WebM，Ogg controls——显示控制面板 loop——循环播放 muted——静音播放 autoplay——自动播放（仅在静音状态下可用，所以必须与muted一起出现） 超链接标签 作用：点击跳转到其他界面（在线or本地） 符号：\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;文字内容\u0026lt;/a\u0026gt; href——跳转地址，是必须属性 \u0026lt;a href=\u0026quot;\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;可实现新窗口跳转页面 开发初期，跳转地址未知，href属性值写#，表示空链接，点击后不会跳转 路径 相对路径 从当前文件夹出发查找目标文件 文件夹名称/——进入某个文件夹 ./——进入当前文件夹 ../——进入上一级文件夹 绝对路径 从盘符（eg：C盘）开始查找目标文件\n1 C:/images/mao.jpg windows默认显示路径时用\\表示进入文件夹，其它系统是/，建议统一写成/ 还可以引用文件的在线网址，可应用于网站的友情链接 小知识 VS Code中Alt+Z可实现文字折行。 ","date":"2023-06-15T13:39:56+08:00","permalink":"https://xiaotianmuyun1113.top/p/html5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"html5 学习笔记"}]